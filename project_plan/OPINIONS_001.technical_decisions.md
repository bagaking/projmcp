---
created_date: 2025-01-24
description: 记录项目开发过程中的关键技术决策和观察，用于指导后续开发
purpose: 保存重要的技术选择依据和决策过程，确保团队理解和一致性
---

# 技术决策和关键观察

## MCP协议选择

### 决策: 选择stdio传输而非HTTP
**观察**: 用户明确要求"npm一行命令执行"，且主要面向Claude等命令行集成场景  
**决策依据**:
1. StdioServerTransport完美适配命令行环境
2. 无需额外的端口配置和网络设置
3. 集成复杂度最低，符合用户的简单性需求
4. 官方文档显示stdio是推荐的命令行工具集成方式

**影响**: 简化了部署流程，但限制了并发连接能力（仅支持单个客户端）

### 决策: 使用McpServer而非低级Server类
**观察**: 官方SDK提供了两种实现方式，McpServer是高级封装  
**决策依据**:
1. 用户需求专注于功能实现，不需要协议层的精细控制
2. McpServer提供了工具注册等便利方法，减少样板代码
3. 官方推荐用于快速开发和标准场景
4. 更好的类型安全和错误处理

**影响**: 开发效率提高，但失去了一些底层控制能力

## API设计原则

### 决策: 优先使用resource_link而非直接文本返回
**观察**: 用户明确要求"节省token"，这是核心需求  
**决策依据**:
1. resource_link避免大量文件内容传输
2. agent可以按需读取具体文件内容
3. 响应格式更结构化，便于agent处理
4. 符合MCP协议的最佳实践

**影响**: 响应格式需要标准化，但大幅减少token消耗

### 决策: 使用zod进行参数验证
**观察**: TypeScript类型安全和运行时验证的需求  
**决策依据**:
1. MCP SDK官方推荐和大量使用zod
2. 提供编译时和运行时双重类型安全  
3. 支持复杂参数验证逻辑（枚举、条件等）
4. 错误信息清晰，便于agent理解

**影响**: 增加了一个依赖，但显著提高了API的健壮性

## 项目结构决策

### 决策: 严格按照最佳实践组织项目结构
**观察**: 用户强调要帮助agent"更好的使用这套最佳实践"  
**决策依据**:
1. 项目本身要成为最佳实践的示范
2. 标准化结构便于维护和扩展
3. 符合Node.js和TypeScript社区规范
4. 便于后续的测试和文档化

**影响**: 前期配置工作较多，但长期维护性更好

### 决策: 分离工具实现到独立模块
**观察**: 用户需求包含多个不同类型的工具（list、record、show等）  
**决策依据**:
1. 单一职责原则，便于单独测试和维护
2. 便于后续功能扩展和修改
3. 代码组织更清晰，易于理解
4. 支持按需加载和动态注册

**影响**: 文件数量增加，但代码复杂度分散管理

## 技术栈决策

### 决策: 使用TypeScript严格模式
**观察**: MCP SDK本身是TypeScript写的，官方示例都启用严格模式  
**决策依据**:
1. 与MCP SDK保持一致的开发体验
2. 严格模式能早期发现潜在问题
3. 更好的IDE支持和开发体验
4. 符合现代TypeScript项目标准

**影响**: 开发时类型约束更严格，但运行时错误显著减少

### 决策: 不引入复杂的构建工具
**观察**: 用户强调简单性，"npm一行命令执行"  
**决策依据**:
1. tsc编译器足够满足当前需求
2. 减少配置复杂度和学习成本
3. 便于部署和环境一致性
4. 符合minimalist原则

**影响**: 构建灵活性受限，但简化了整体复杂度

## 用户体验设计

### 决策: 错误信息要具体和可操作
**观察**: agent需要能够理解错误并采取正确的修复行动  
**决策依据**:
1. 模糊错误信息会导致agent重复尝试错误操作
2. 具体的错误指导能提高agent的执行效率
3. 减少用户的调试和干预需求
4. 符合开发者工具的用户体验标准

**影响**: 需要为每种错误场景编写详细的错误信息

### 决策: 支持增量操作而非全量重建
**观察**: agent在项目管理过程中会频繁进行小幅修改  
**决策依据**:
1. 增量操作避免不必要的文件重写
2. 减少文件系统IO，提高性能
3. 保留用户的手工修改内容
4. 符合现代开发工具的交互模式

**影响**: 实现逻辑更复杂，需要状态管理

## 质量保证原则

### 决策: 遵循官方代码规范而非自定义规范
**观察**: MCP SDK有明确的代码规范指导  
**决策依据**:
1. 保持与生态系统的一致性
2. 减少决策负担和争议
3. 便于贡献代码回社区
4. 自动化工具支持更好

**影响**: 需要遵循较严格的代码格式要求

### 决策: 优先保证功能完整性而非性能极致优化
**观察**: 用户场景主要是本地文件操作，性能瓶颈不在计算  
**决策依据**:
1. 项目管理场景对实时性要求不高
2. 过早优化可能影响代码可读性
3. 功能正确性比性能更重要
4. 优化可以在后续版本迭代中进行

**影响**: 为了代码清晰性可能牺牲一些性能机会

## 未来演进考虑

### 观察: MCP协议还在快速发展
**影响**: 需要保持API设计的前向兼容性，避免破坏性变更  
**应对策略**: 
1. 使用语义版本控制
2. 及时跟进官方SDK更新
3. 保持API接口的稳定性
4. 通过配置支持不同协议版本

### 观察: 用户可能有扩展需求
**影响**: 架构设计要考虑可扩展性  
**应对策略**:
1. 插件化的工具注册机制
2. 配置文件支持自定义模板
3. 事件驱动的通知机制
4. 清晰的公共API边界

这些决策将指导整个项目的开发过程，在遇到相似问题时应该参考这些已经确定的原则。